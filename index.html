<html>

    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <canvas id="myCanvas" width="800" height="600" style="border:1px solid #000000;"></canvas>

    <br>
    <button id="random" class="menu">Random</button>
    <button id="compute" class="menu">Compute</button>
    <button id="clear" class="menu">Clear</button>
    <input id="input" type="file" accept=".txt" hidden="hidden">
    <label for="input" class="menu">Load</label>
    <button id="coords" class="menu">Coords</button>
    <button id="unclutter" class="menu">Unclutter</button>
    <select id="algorithm">
        <option>Brute</option>
        <option>Recursive</option>
		<option>Calipers</option>
    </select>
	<button id="maxExec" class="menu">Max Execution</button>
	<input id="max" type="number" class="coord"> (ms)
	 <div>
        <div style="float:left">
            <br>
            A:
            x<input  id ="ax" type="number" class="coord">
            y<input  id ="ay" type="number" class="coord">
            <br>
            B:
            x<input  id ="bx" type="number" class="coord">
            y<input  id ="by" type="number" class="coord">
            <br>
            C:
            x<input  id ="cx" type="number" class="coord">
            y<input  id ="cy" type="number" class="coord">
        </div>
        <button id="testCircle" class="menu" style="float:left; margin-top: 40px; margin-left: 10px">Test Circle</button>
        <div id="circleRes" style="float:left; margin-top: 40px; margin-left: 10px"> </div>
    </div>
	
	
	<script>
		const X = 0;
		const Y = 1;
		var $canvas = $("#myCanvas");
        var canvas = $canvas[0];
        var c = canvas.getContext("2d");
        var pointList = [];
        var circleSize = 5;
        var restorePoint;
        var cluttered = false;
		var isBrute = true;
		let calipers = false;

        c.fillStyle = "#CA1337"



        function addPoint (x, y)
        {
            var invertedY = canvas.height -y;
            pointList.push([x,y]);
            c.strokeStyle = "#000000";
            c.beginPath();
            c.arc(x,invertedY, circleSize, 0, 2*Math.PI, false);
            c.fill();
            c.stroke();
        }

		$canvas.click(function(e)
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
            var xCord = e.pageX - canvas.offsetLeft;
            var yCord = e.pageY - canvas.offsetTop;
            addPoint(xCord, canvas.height - yCord);
        });

		$("#algorithm").change(function()
        {
			var choice = $(this).val();
			if( choice == "Brute")
			{
				isBrute = true;
				calipers = false;
			}
			else if(choice == "Recursive")
			{
				isBrute = false;
				calipers = false;
			}
			else if(choice == "Calipers")
				calipers = true;
		});

		$("#clear").click(function()
        {
            cluttered = false;
            pointList.length = 0;
            c.clearRect(0,0, canvas.width, canvas.height);
        });
		
		$("#coords").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
            for(var i = 0; i < pointList.length; i++)
            {
                c.strokeStyle = "#000000";
                c.strokeText(pointList[i][X] + " : " + pointList[i][Y], pointList[i][X], canvas.height - pointList[i][Y] - 20);
            }
        });
		
		$("#unclutter").click(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
        });
		
		$("#input").change(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
            var file = this.files[0];
            $(this).val("");
            var reader = new FileReader();

            reader.onload = function(e)
            {
                var text = reader.result;
                var lines = text.split(/[\r\n]+/g);

                for (var i = 0; i < lines.length; i++)
                {
                    coords = lines[i].split(" ");
                    if(coords.length != 2 || isNaN(coords[X]) || isNaN(coords[Y]))
                    {
                        alert("Error reading file on line "+ i);
                        return;
                    }
                    addPoint(parseInt(coords[X]), parseInt(coords[Y]));
                }
            };
            reader.readAsText(file);
        });
		
		$("#random").click(function (e)
        {
			if(cluttered)
			{
				c.putImageData(restorePoint, 0, 0);
				cluttered = false;
			}
			var num = Math.random()*40+5;

			random(num);
        });

		function random (n)	
		{
			for(var i = 0; i < n; i++)
			{
				var x = Math.floor(Math.random()*canvas.width/2 + canvas.width/4);
				var y = Math.floor(Math.random()*canvas.height/2 + canvas.height/4);
				pointList.push([x,y]);
			}
		}
		
		$("#testCircle").click(function()
		{
			console.log("!!!!!!!!!Test!!!!!!!!!!!!");
			var ax = parseInt($("#ax").val());
            var ay = parseInt($("#ay").val());
            var bx = parseInt($("#bx").val());
            var by = parseInt($("#by").val());
            var cx = parseInt($("#cx").val());
            var cy = parseInt($("#cy").val());
			
            if (!(isNaN(ax) || isNaN(ay) || isNaN(bx) || isNaN(by)))
			{
				if(!cluttered)
					restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
				cluttered = true;

				var circ; 
	            if (!( isNaN(cx) || isNaN(cy)))
				{
					circ = circle([ax,ay], [bx,by], [cx, cy]);
				}
				else
				{
					circ = circle([ax,ay], [bx, by]);
				}
				console.log(circ);
				c.strokeStyle = "#009999";
				c.beginPath();
				c.arc(circ[0][X], canvas.height - circ[0][Y], circ[1], 0, Math.PI*2);
				c.stroke();
				for (var i = 0; i < pointList.length; i++)
				{
					if(!inside(circ, pointList[i]))
					{
						console.log(pointList[i][X] + " : " + pointList[i][Y]); 
					}
				}
			}

		});

		$("#maxExec").click(function()
		{
			var max = parseInt($("#max").val());
			if(!isNaN(max))
			{
				var oldList = pointList.slice();
				pointList.length = 0;
				random(2);
				var lastIncrease = 1;
				var lastExec = 0;
				var error = 0;
				var run = true;
				var over = false;
				var bigger = false;
				var biggest = 0;
				var lowest = 0;
				var tot0 = performance.now();
				while (run)
				{
					var increase;
					if(over)
					{
						increase = Math.ceil((biggest - lowest) /2);
					}
					else
						increase = lastIncrease * 2;
					random(increase);
					var t0 = performance.now();
					if(isBrute)
						brute();
					else
						minDisc();
					var t1 = performance.now();
					if(t1-t0 > max)
					{
						error ++;
						over = true;
						bigger = true;
						biggest = pointList.length;

						pointList.length = 0;
						random(lowest);			//go back to last point

						if(error > 10)
						{
							console.log("error");
							run = false;
						}
					}
					else
					{
						error = 0;
						bigger = false;
						lowest = pointList.length;
						lastExec = t1-t0;
					}
					if(over && biggest-lowest < 2 )
					{
						run = false;
					}
					lastIncrease = increase;
				}
				var tot1 = performance.now();
				console.log("Closest points: "+ lowest);
				console.log("Closest Execution: " + lastExec);
				console.log("Total time: " + (tot1 - tot0));
				pointList = oldList;
			}
		});
		
		$("#compute").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
			var res;
			var t0 = performance.now();
			if(calipers)
				res = rotatingCalipers();
			else
				res = (isBrute? brute() : minDisc());
			var t1 = performance.now();
			console.log(res);
			console.log("Execution time (ms) : " + (t1-t0));
			c.strokeStyle = "#000000";
			c.beginPath();
			c.arc(res[0][X], canvas.height - res[0][Y], res[1], 0, Math.PI*2);
			c.stroke();
        });
		
		function inside(circ, point)//a, b, c, d)
		{
			var mid = circ[0];
			var diffX = mid[X] - point[X];
			var diffY = mid[Y] - point[Y];
			var distance = Math.sqrt(diffX * diffX + diffY * diffY);
			if (distance > circ[1])
				return false;
			return true;
		}

		function findIntersection( p1, p2, p3, p4)
		{
			var dx12 = p2[X] - p1[X];
			var dy12 = p2[Y] - p1[Y];
			var dx34 = p4[X] - p3[X];
			var dy34 = p4[Y] - p3[Y];

			var denominator = (dy12 * dx34 - dx12 * dy34);
			var t1 = ((p1[X] - p3[X]) * dy34 + (p3[Y] - p1[Y]) * dx34) / denominator;
			if (t1 == Infinity)
			{
				return false;
			}

			//var t2 = ((p3[X] - p1[X]) * dy12 + (p1[Y] - p3[Y]) * dx12) / denominator;
			var intersection = [p1[X] + dx12 * t1, p1[Y] + dy12 * t1];
			return intersection;

		}

		function circle(a, b, c)
		{
		var center;
		var radius;
			if (c == undefined)
			{
				var diffX = ((a[X] - b[X])/2);
				var diffY = ((a[Y] - b[Y])/2);
				center = [diffX + b[X], diffY + b[Y]];
				radius = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
			}
			else	//Got link to these calculations from Mattias. http://csharphelper.com/blog/2016/09/draw-a-circle-through-three-points-in-c/
			{

				var x1 = (b[X] + a[X]) / 2;
				var y1 = (b[Y] + a[Y]) / 2;
				var dy1 = b[X] - a[X];
				var dx1 = -(b[Y] - a[Y]);

				var x2 = (c[X] + b[X]) / 2;
				var y2 = (c[Y] + b[Y]) / 2;
				var dy2 = c[X] - b[X];
				var dx2 = -(c[Y] - b[Y]);

				var intersection = findIntersection([x1, y1] , [x1 + dx1, y1 + dy1], [x2, y2], [x2 +dx2, y2+dy2]);

				if( intersection == false)
				{
					center = [0,0];
					radius = 0;
				}
				else
				{
					center = intersection;
					var dx = center[X] - a[X];
					var dy = center[Y] - a[Y];
					radius = Math.sqrt(dx*dx + dy*dy);
				}

				/*var m1 = (b[Y] - a[Y]) / (b[X] - a[X]);
				var m2 = (c[Y] - b[Y]) / (c[X] - b[X]);
				var x = (m1 * m2 * (c[Y] - a[Y]) + m1* (b[X]+c[X]) + m2 * (a[X] + b[X])) / (2 * (m1 - m2));
				var y = (1/m1) * (x - (a[X] + b[X]) / 2) + (a[Y] + b[Y]) / 2;
				center = [x, y]
				radius = Math.sqrt(Math.pow(x - a[X], 2) + Math.pow(y - a[Y], 2));
				*/
				/*
				float m1 = (point2.Y - point1.Y) / (point2.X - point1.X);
            float m2 = (point3.Y - point2.Y) / (point3.X - point2.X);

            float X = (m1 * m2 * (point3.Y - point1.Y) + m1 * (point2.X + point3.X) + m2 * (point1.X + point2.X)) / (2 * (m1 - m2));
            float Y = (1 / m1) * (X - (point1.X + point2.X) / 2) + (point1.Y + point2.Y) / 2;
            Center = new Vector2(X, Y);
            Radius = (Center - point1).Length();
				*/
			}
			return [center, radius];
		}
		
		function brute()
		{
			if(pointList.length < 2)
			{
				return [pointList[X], 0];
			}
			else if (pointList.length < 3)
			{
				return circle(pointList[0], pointList[1]);
			}
			else 
			{
				var minCircle = [[0,0], Number.MAX_SAFE_INTEGER];
				for (var i = 0; i < pointList.length-1; i++)
				{
					for(var j = i+1; (j < pointList.length); j++)
					{
						var fault = false;
						var tmpCirc = circle(pointList[i], pointList[j]);
						for (var k = 0; k < pointList.length && !fault; k++)
						{
							if(k == i || k == j)
								continue;
							else
								if(!inside(tmpCirc, pointList[k])) 
									fault = true;
						}
						if (!fault && tmpCirc[1] < minCircle[1])
						{
							minCircle = tmpCirc;
						}
					}
				}
				for (var i= 0; i < pointList.length-2; i++)
				{
					for(var j = i+1; j < pointList.length-1; j++)
					{
						for(var k = j+1; k < pointList.length; k++)
						{
							var fault = false;
							var tmpCirc = circle(pointList[i], pointList[j], pointList[k]);
							for(var l = 0; l < pointList.length && !fault; l++)
							{
								if(l== i || l == j || l == k)
									continue;
								else
									if(!inside(tmpCirc, pointList[l]))
										fault = true;
							}
							if (!fault && tmpCirc[1] < minCircle[1])
							{
								minCircle = tmpCirc;
							}
						}
					}
				}
				return minCircle;
			}
		}
		function shuffle(array) 
		{
			var currentIndex = array.length, temporaryValue, randomIndex;

			// While there remain elements to shuffle...
			while (0 !== currentIndex) 
			{
				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
			}
			return array;
		}
		
		function minDiscWith2Points(i, p1, p2)
		{
			var D = shuffle(pointList.slice(0, i));
			var disc = circle(p1, p2);
			for (var k = 0; k < D.length; k++)
			{
				console.log(inside(disc, D[i]));
				if(!inside(disc, D[k]))
					disc = circle(p1, p2, D[k]);
			}
			return disc;
		}
		
		function minDiscWithPoint(i, p)
		{
			var D = shuffle(pointList.slice(0, i));
			var disc = circle (D[0], p);
			for(var j = 1; j < D.length; j++)
			{
					console.log(inside(disc, D[i]));
					if(!inside(disc, D[j]))
						disc = minDiscWith2Points(j, D[j], p);
			}
			return disc;
		}
		
		function minDisc()
		{
			var D = shuffle(pointList.slice());
			if(D.length > 1)
			{
				disc = circle(D[0], D[1]);
				for (var i = 2; i < D.length; i++)
				{
					console.log(inside(disc, D[i]));
					if(!inside(disc, D[i]))
						disc = minDiscWithPoint(i, D[i]);
				}
			}
			return disc;
		}
		
		function crossing (a, b, c)
		{
			let v2 = [b[X] - a[X], b[Y] - a[Y]];
			let v1 = [c[X] - b[X], c[Y] - b[Y]];
			let cross = v1[X]*v2[Y] - v1[Y]*v2[X];
			return cross > 0;
		}
		
        function isRightTurn(a, b, c)  // y = kx * c
        {
            if((b[0] == c[0] && b[1] == c[1]) || (a[0] == b[0] && a[1] == b[1]))
                return false;
			if(a[0] == b[0])
			{
				var downToUp = a[1] < b[1];
				if (c[0] > a[0])
				{
					if(downToUp)
						return true;
					else
						return false;
				}
				else
				{
					if(downToUp)
						return false;
					else
						return true;
				}
			}
			else
			{
				var goingRight = a[0] < b[0];
				var koef = (a[1] - b[1]) / (a[0] - b[0]);
				var con = (-a[0] * koef) + a[1];
				
				if(goingRight)
				{
					if(c[1] < koef * c[0] + con)
						return true;
					else
						return false;
				}
				else
				{
					if(c[1] > koef * c[0] + con)
						return true;
					else
						return false;
				}
			}
		}
		
        function Andrew ()
        {
            pointList.sort(function (a, b)
            {
                if(a[0] == b[0])
                    return a[1] - b[1];
                return a[0] - b[0];         //Sort by x coordinate (index 0)
            })
            var upperHull = [];
            var lowerHull = [];
            var onlyOne = false;
            var i = 0;
            var right = true;
            var change = 1;
            var hull = upperHull;
            for (var p = 0; p < 2; p++)
            {
                while ((i < pointList.length && right) || (i >= 0 && !right))
                {
                    if (hull.length >= 2)
                    {
                        var a = hull[hull.length - 2];
                        var b = hull[hull.length - 1];
                        while (!onlyOne && !isRightTurn(a, b, pointList[i]))
                        {
                            hull.pop()
                            if (hull.length > 1)
                            {
                                a = hull[hull.length - 2];
                                b = hull[hull.length - 1];
                            }
                            else
                            {
                                onlyOne = true;
                            }
                        }
                    }
                    if (hull.length == 1)
                    {
                        if(!(hull[0][0] == pointList[i][0] && hull[0][1] == pointList[i][1]))
                            hull.push(pointList[i]);
                    }
                    else
                        hull.push(pointList[i]);
                    if (hull.length > 1)
                    {
                        onlyOne = false;
                    }
                    i = i + change;
                }
                i--;
                change = -1;
                right = false;
                hull = lowerHull;
            }
            var res = upperHull.concat(lowerHull.slice(1, lowerHull.length-1));
			
            return res;
        }
		
		function rotatingCalipers()
		{
			//let hull = Andrew();
			a = [1,1];
			b = [2,2];
			c = [3, 2];
			console.log(crossing(a, b, c));
			console.log(isRightTurn(a, b, c));
		}
		
		

	</script>
</html>