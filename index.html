<html>

    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <canvas id="myCanvas" width="800" height="600" style="border:1px solid #000000;"></canvas>

    <br>
    <button id="random" class="menu">Random</button>
    <button id="compute" class="menu">Compute</button>
    <button id="clear" class="menu">Clear</button>
    <input id="input" type="file" accept=".txt" hidden="hidden">
    <label for="input" class="menu">Load</label>
    <button id="coords" class="menu">Coords</button>
    <button id="unclutter" class="menu">Unclutter</button>
    <select id="algorithm">
        <option>Brute</option>
        <option>Recursive</option>
		<option>Calipers</option>
    </select>
	<button id="maxExec" class="menu">Max Execution</button>
	<input id="max" type="number" class="coord"> (ms)
    <button id="test" class="menu">test</button>
    <div>
        <div style="float:left">
            <br>
            A:
            x<input  id ="ax" type="number" class="coord">
            y<input  id ="ay" type="number" class="coord">
            <br>
            B:
            x<input  id ="bx" type="number" class="coord">
            y<input  id ="by" type="number" class="coord">
            <br>
            C:
            x<input  id ="cx" type="number" class="coord">
            y<input  id ="cy" type="number" class="coord">
        </div>
        <button id="testCircle" class="menu" style="float:left; margin-top: 40px; margin-left: 10px">Test Circle</button>
        <div id="circleRes" style="float:left; margin-top: 40px; margin-left: 10px"> </div>
    </div>
	
	
	<script>
		const X = 0;
		const Y = 1;
		const $canvas = $("#myCanvas");
		const canvas = $canvas[0];
		const c = canvas.getContext("2d");
		let pointList = [];
		const circleSize = 5;
		let restorePoint;
		let cluttered = false;
		let isBrute = true;
		let calipers = false;

        c.fillStyle = "#CA1337";



        function addPoint (x, y)
        {
	        const invertedY = canvas.height - y;
            pointList.push([x,y]);
            c.strokeStyle = "#000000";
            c.beginPath();
            c.arc(x,invertedY, circleSize, 0, 2*Math.PI, false);
            c.fill();
            c.stroke();
        }

		$canvas.click(function(e)
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
	        const xCord = e.pageX - canvas.offsetLeft;
	        const yCord = e.pageY - canvas.offsetTop;
            addPoint(xCord, canvas.height - yCord);
        });

		$("#algorithm").change(function()
        {
	        const choice = $(this).val();
			if( choice == "Brute")
			{
				isBrute = true;
				calipers = false;
			}
			else if(choice == "Recursive")
			{
				isBrute = false;
				calipers = false;
			}
			else if(choice == "Calipers")
				calipers = true;
		});

		$("#clear").click(function()
        {
            cluttered = false;
            pointList.length = 0;
            c.clearRect(0,0, canvas.width, canvas.height);
        });
		
		$("#coords").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
            for(let i = 0; i < pointList.length; i++)
            {
                c.strokeStyle = "#000000";
                c.strokeText(pointList[i][X] + " : " + pointList[i][Y], pointList[i][X], canvas.height - pointList[i][Y] - 20);
            }
        });
		
		$("#unclutter").click(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
        });
		
		$("#input").change(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
	        const file = this.files[0];
            $(this).val("");
	        const reader = new FileReader();

            reader.onload = function(e)
            {
	            const text = reader.result;
	            const lines = text.split(/[\r\n]+/g);

                for (let i = 0; i < lines.length; i++)
                {
                    coords = lines[i].split(" ");
                    if(coords.length != 2 || isNaN(coords[X]) || isNaN(coords[Y]))
                    {
                        alert("Error reading file on line "+ i);
                        return;
                    }
                    addPoint(parseInt(coords[X]), parseInt(coords[Y]));
                }
            };
            reader.readAsText(file);
        });
		
		$("#random").click(function (e)
        {
			if(cluttered)
			{
				c.putImageData(restorePoint, 0, 0);
				cluttered = false;
			}
	        const num = Math.random() * 40 + 5;

			random(num);
        });

		function random (n)	
		{
			for(var i = 0; i < n; i++)
			{
				const x = Math.floor(Math.random() * canvas.width / 2 + canvas.width / 4);
				const y = Math.floor(Math.random() * canvas.height / 2 + canvas.height / 4);
				pointList.push([x,y]);
			}
		}
		
		$("#testCircle").click(function()
		{
			console.log("!!!!!!!!!Test!!!!!!!!!!!!");
			const ax = parseInt($("#ax").val());
			const ay = parseInt($("#ay").val());
			const bx = parseInt($("#bx").val());
			const by = parseInt($("#by").val());
			const cx = parseInt($("#cx").val());
			const cy = parseInt($("#cy").val());
			
            if (!(isNaN(ax) || isNaN(ay) || isNaN(bx) || isNaN(by)))
			{
				if(!cluttered)
					restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
				cluttered = true;

				let circ;
	            if (!( isNaN(cx) || isNaN(cy)))
				{
					circ = circle([ax,ay], [bx,by], [cx, cy]);
				}
				else
				{
					circ = circle([ax,ay], [bx, by]);
				}
				console.log(circ);
				c.strokeStyle = "#009999";
				c.beginPath();
				c.arc(circ[0][X], canvas.height - circ[0][Y], circ[1], 0, Math.PI*2);
				c.stroke();
				for (let i = 0; i < pointList.length; i++)
				{
					if(!inside(circ, pointList[i]))
					{
						console.log(pointList[i][X] + " : " + pointList[i][Y]); 
					}
				}
			}

		});

		$("#maxExec").click(function()
		{
			const max = parseInt($("#max").val());
			if(!isNaN(max))
			{
				const oldList = pointList.slice();
				pointList.length = 0;
				random(2);
				let lastIncrease = 1;
				let lastExec = 0;
				let error = 0;
				let run = true;
				let over = false;
				let bigger = false;
				let biggest = 0;
				let lowest = 0;
				const tot0 = performance.now();
				while (run)
				{
					let increase;
					if(over)
					{
						increase = Math.ceil((biggest - lowest) /2);
					}
					else
						increase = lastIncrease * 2;
					random(increase);
					const t0 = performance.now();
					if(isBrute)
						brute();
					else
						minDisc();
					const t1 = performance.now();
					if(t1-t0 > max)
					{
						error ++;
						over = true;
						bigger = true;
						biggest = pointList.length;

						pointList.length = 0;
						random(lowest);			//go back to last point

						if(error > 10)
						{
							console.log("error");
							run = false;
						}
					}
					else
					{
						error = 0;
						bigger = false;
						lowest = pointList.length;
						lastExec = t1-t0;
					}
					if(over && biggest-lowest < 2 )
					{
						run = false;
					}
					lastIncrease = increase;
				}
				const tot1 = performance.now();
				console.log("Closest points: "+ lowest);
				console.log("Closest Execution: " + lastExec);
				console.log("Total time: " + (tot1 - tot0));
				pointList = oldList;
			}
		});
		
		$("#compute").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
			var res;
			var t0 = performance.now();
			if(calipers)
				res = rotatingCalipers();
			else
				res = (isBrute? brute() : minDisc());
			var t1 = performance.now();
			console.log(res);
			console.log("Execution time (ms) : " + (t1-t0));
			c.strokeStyle = "#000000";
			c.beginPath();
			c.arc(res[0][X], canvas.height - res[0][Y], res[1], 0, Math.PI*2);
			c.stroke();
        });
		
		function inside(circ, point)//a, b, c, d)
		{
			const mid = circ[0];
			const diffX = mid[X] - point[X];
			const diffY = mid[Y] - point[Y];
			const distance = Math.sqrt(diffX * diffX + diffY * diffY);
			return distance <= circ[1];
		}

		function findIntersection( p1, p2, p3, p4)
		{
			const dx12 = p2[X] - p1[X];
			const dy12 = p2[Y] - p1[Y];
			const dx34 = p4[X] - p3[X];
			const dy34 = p4[Y] - p3[Y];

			const denominator = (dy12 * dx34 - dx12 * dy34);
			const t1 = ((p1[X] - p3[X]) * dy34 + (p3[Y] - p1[Y]) * dx34) / denominator;
			if (t1 == Infinity)
			{
				return false;
			}

			//var t2 = ((p3[X] - p1[X]) * dy12 + (p1[Y] - p3[Y]) * dx12) / denominator;
			const intersection = [p1[X] + dx12 * t1, p1[Y] + dy12 * t1];
			return intersection;

		}

		function circle(a, b, c)
		{
			let center;
			let radius;
			if (c == undefined)
			{
				const diffX = ((a[X] - b[X]) / 2);
				const diffY = ((a[Y] - b[Y]) / 2);
				center = [diffX + b[X], diffY + b[Y]];
				radius = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
			}
			else	//Got link to these calculations from Mattias. http://csharphelper.com/blog/2016/09/draw-a-circle-through-three-points-in-c/
			{

				const x1 = (b[X] + a[X]) / 2;
				const y1 = (b[Y] + a[Y]) / 2;
				const dy1 = b[X] - a[X];
				const dx1 = -(b[Y] - a[Y]);

				const x2 = (c[X] + b[X]) / 2;
				const y2 = (c[Y] + b[Y]) / 2;
				const dy2 = c[X] - b[X];
				const dx2 = -(c[Y] - b[Y]);

				const intersection = findIntersection([x1, y1], [x1 + dx1, y1 + dy1], [x2, y2], [x2 + dx2, y2 + dy2]);

				if( intersection == false)
				{
					center = [0,0];
					radius = 0;
				}
				else
				{
					center = intersection;
					const dx = center[X] - a[X];
					const dy = center[Y] - a[Y];
					radius = Math.sqrt(dx*dx + dy*dy);
				}

				/*var m1 = (b[Y] - a[Y]) / (b[X] - a[X]);
				var m2 = (c[Y] - b[Y]) / (c[X] - b[X]);
				var x = (m1 * m2 * (c[Y] - a[Y]) + m1* (b[X]+c[X]) + m2 * (a[X] + b[X])) / (2 * (m1 - m2));
				var y = (1/m1) * (x - (a[X] + b[X]) / 2) + (a[Y] + b[Y]) / 2;
				center = [x, y]
				radius = Math.sqrt(Math.pow(x - a[X], 2) + Math.pow(y - a[Y], 2));
				*/
				/*
				float m1 = (point2.Y - point1.Y) / (point2.X - point1.X);
            float m2 = (point3.Y - point2.Y) / (point3.X - point2.X);

            float X = (m1 * m2 * (point3.Y - point1.Y) + m1 * (point2.X + point3.X) + m2 * (point1.X + point2.X)) / (2 * (m1 - m2));
            float Y = (1 / m1) * (X - (point1.X + point2.X) / 2) + (point1.Y + point2.Y) / 2;
            Center = new Vector2(X, Y);
            Radius = (Center - point1).Length();
				*/
			}
			return [center, radius];
		}
		
		function brute()
		{
			if(pointList.length < 2)
			{
				return [pointList[X], 0];
			}
			else if (pointList.length < 3)
			{
				return circle(pointList[0], pointList[1]);
			}
			else 
			{
				let minCircle = [[0, 0], Number.MAX_SAFE_INTEGER];
				for (let i = 0; i < pointList.length-1; i++)
				{
					for(let j = i+1; (j < pointList.length); j++)
					{
						let fault = false;
						let tmpCirc = circle(pointList[i], pointList[j]);
						for (let k = 0; k < pointList.length && !fault; k++)
						{
							if(!(k == i || k == j))
								if(!inside(tmpCirc, pointList[k])) 
									fault = true;
						}
						if (!fault && tmpCirc[1] < minCircle[1])
						{
							minCircle = tmpCirc;
						}
					}
				}
				for (let i= 0; i < pointList.length-2; i++)
				{
					for(let j = i+1; j < pointList.length-1; j++)
					{
						for(let k = j+1; k < pointList.length; k++)
						{
							let fault = false;
							let tmpCirc = circle(pointList[i], pointList[j], pointList[k]);
							for(let l = 0; l < pointList.length && !fault; l++)
							{
								if(!(l== i || l == j || l == k))
									if(!inside(tmpCirc, pointList[l]))
										fault = true;
							}
							if (!fault && tmpCirc[1] < minCircle[1])
							{
								minCircle = tmpCirc;
							}
						}
					}
				}
				return minCircle;
			}
		}
		function shuffle(array) 
		{
			let currentIndex = array.length, temporaryValue, randomIndex;

			// While there remain elements to shuffle...
			while (0 !== currentIndex) 
			{
				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
			}
			return array;
		}
		
		function minDiscWith2Points(D, p1, p2)
		{
			shuffle(D);
			let disc = circle(p1, p2);
			for (let k = 0; k < D.length; k++)
			{
				if(!inside(disc, D[k]))
					disc = circle(p1, p2, D[k]);
			}
			return disc;
		}
		
		function minDiscWithPoint(D, p)
		{
			shuffle(D);
			let disc = circle(D[0], p);
			for(let j = 1; j < D.length; j++)
			{
					if(!inside(disc, D[j]))
						disc = minDiscWith2Points(D.slice(0,j), D[j], p);
			}
			return disc;
		}
		
		function minDisc()
		{
			const D = shuffle(pointList.slice());
			if(D.length > 1)
			{
				let disc = circle(D[0], D[1]);
				for (let i = 2; i < D.length; i++)
				{
					if(!inside(disc, D[i]))
						disc = minDiscWithPoint(D.slice(0, i), D[i]);

				}
				return disc;
			}
			else
				return [pointList[0], 0];
		}

        $("#test").click(function ()
        {
           const list = [1,2,3,4,5,6,7,8,9];
           console.log(list);
           const alt = shuffle(list.slice());
           console.log(alt);
           const small = list.slice(5);
           console.log(small);
           console.log(shuffle(small.slice()));
           console.log(small);
           shuffle(small);
           console.log(small);
        });
		
		function isRightTurn (a, b, c)
		{
			let v2 = [b[X] - a[X], b[Y] - a[Y]];
			let v1 = [c[X] - b[X], c[Y] - b[Y]];
			let cross = v1[X]*v2[Y] - v1[Y]*v2[X];
			return cross > 0;
		}
		
        function Andrew ()
        {
            pointList.sort(function (a, b)
            {
                if(a[0] == b[0])
                    return a[1] - b[1];
                return a[0] - b[0];         //Sort by x coordinate (index 0)
            })
            var upperHull = [];
            var lowerHull = [];
            var onlyOne = false;
            var i = 0;
            var right = true;
            var change = 1;
            var hull = upperHull;
            for (var p = 0; p < 2; p++)
            {
                while ((i < pointList.length && right) || (i >= 0 && !right))
                {
                    if (hull.length >= 2)
                    {
                        var a = hull[hull.length - 2];
                        var b = hull[hull.length - 1];
                        while (!onlyOne && !isRightTurn(a, b, pointList[i]))
                        {
                            hull.pop()
                            if (hull.length > 1)
                            {
                                a = hull[hull.length - 2];
                                b = hull[hull.length - 1];
                            }
                            else
                            {
                                onlyOne = true;
                            }
                        }
                    }
                    if (hull.length == 1)
                    {
                        if(!(hull[0][0] == pointList[i][0] && hull[0][1] == pointList[i][1]))
                            hull.push(pointList[i]);
                    }
                    else
                        hull.push(pointList[i]);
                    if (hull.length > 1)
                    {
                        onlyOne = false;
                    }
                    i = i + change;
                }
                i--;
                change = -1;
                right = false;
                hull = lowerHull;
            }
            var res = upperHull.concat(lowerHull.slice(1, lowerHull.length-1));
			
            return res;
        }
		
		function rotatingCalipers()
		{
			let hull = Andrew();
			
		}		

	</script>
</html>