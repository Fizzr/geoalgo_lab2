<html>

    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <canvas id="myCanvas" width="800" height="600" style="border:1px solid #000000;"></canvas>

    <br>
    <button id="random" class="menu">Random</button>
    <button id="compute" class="menu">Compute</button>
    <button id="clear" class="menu">Clear</button>
    <input id="input" type="file" accept=".txt" hidden="hidden">
    <label for="input" class="menu">Load</label>
    <button id="coords" class="menu">Coords</button>
    <button id="unclutter" class="menu">Unclutter</button>
    <select id="algorithm">
        <option>Andrew</option>
        <option>Melkman</option>
    </select>
	
	<script>
		const X = 0;
		const Y = 1;
		var $canvas = $("#myCanvas");
        var canvas = $canvas[0];
        var c = canvas.getContext("2d");
        var pointList = [];
        var circleSize = 5;
        var restorePoint;
        var cluttered = false;

        c.fillStyle = "#CA1337"



        function addPoint (x, y)
        {
            var invertedY = canvas.height -y;
            pointList.push([x,y]);
            c.strokeStyle = "#000000";
            c.beginPath();
            c.arc(x,invertedY, circleSize, 0, 2*Math.PI, false);
            c.fill();
            c.stroke();
        }
		
		$canvas.click(function(e)
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
            var xCord = e.pageX - canvas.offsetLeft;
            var yCord = e.pageY - canvas.offsetTop;
            addPoint(xCord, canvas.height - yCord);
        });

		$("#algorithm").change(function()
        {
            cluttered = false;
            pointList.length = 0;
            c.clearRect(0,0, canvas.width, canvas.height);
        });
		
		$("#clear").click(function()
        {
            cluttered = false;
            pointList.length = 0;
            c.clearRect(0,0, canvas.width, canvas.height);
        });
		
		$("#coords").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
            for(var i = 0; i < pointList.length; i++)
            {
                c.strokeStyle = "#000000";
                c.strokeText(pointList[i][X] + " : " + pointList[i][Y], pointList[i][X], canvas.height - pointList[i][Y] - 20);
            }
        });
		
		$("#unclutter").click(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
        });
		
		$("#input").change(function()
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
            var file = this.files[0];
            $(this).val("");
            var reader = new FileReader();

            reader.onload = function(e)
            {
                var text = reader.result;
                var lines = text.split(/[\r\n]+/g);

                for (var i = 0; i < lines.length; i++)
                {
                    coords = lines[i].split(" ");
                    if(coords.length != 2 || isNaN(coords[X]) || isNaN(coords[Y]))
                    {
                        alert("Error reading file on line "+ i);
                        return;
                    }
                    addPoint(parseInt(coords[X]), parseInt(coords[Y]));
                }
            };
            reader.readAsText(file);
        });
		
		$("#random").click(function (e)
        {
            if(cluttered)
            {
                c.putImageData(restorePoint, 0, 0);
                cluttered = false;
            }
            var num = Math.random()*40+5;

            for(var i = 0; i < num; i++)
            {
                var x = Math.floor(Math.random()*canvas.width);
                var y = Math.floor(Math.random()*canvas.height);
                addPoint(x,y);
            }
        });
		
		$("#compute").click(function()
        {
            if(!cluttered)
                restorePoint = c.getImageData(0,0, canvas.width, canvas.height);
            cluttered = true;
			var res = brute();
			console.log(res);
			c.strokeStyle = "#000000";
			c.beginPath();
			c.arc(res[0][X], canvas.height - res[0][Y], res[1], 0, Math.PI*2);
			c.stroke();

			
        });
		
		function inside(circ, point)//a, b, c, d)
		{
			var mid = circ[0];
			var diffX = mid[X] - point[X];
			var diffY = mid[Y] - point[Y];
			var distance = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
			if (distance > circ[1])
				return false;
			return true;
		
			/*if(d == undefined)
			{
				//Find middle point and its radius, then compare with distance to point
			
				d = c; //if we only get three arguments, the circle only has 2 points, and the third argument is the point we're checking!
				var diffX = ((a[X] - b[X])/2);
				var diffY = ((a[Y] - b[Y])/2);
				var midX = diffX + b[X];
				var midY = diffY + b[Y];
				var radius = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
				var distance = Math.sqrt(Math.pow(midX - d[X], 2) + Math.pow(midY - d[Y], 2));
				return radius <= distance;
				
			}
			else
			{			//No idea how this works, but the document says it's so!
				/*var adx = a[X] - d[X];
				var ady = a[Y] - d[Y];
				var bdx = b[X] - d[X];
				var bdy = b[Y] - d[Y];
				var cdx = c[X] - d[X];
				var cdy = c[Y] - d[Y];
				var abdet = (adx * bdy) - (bdx * ady);
				var bcdet = (bdx * cdy) - (cdx * bdy);
				var cadet = (cdx * ady) - (adx * cdy);
				var alift = (adx * adx) + (ady * ady);
				var blift = (bdx * bdx) + (bdy * bdy);
				var clift = (cdx * cdx) + (cdy * cdy);
				var sign = (alift * bcdet) + (blift * cadet) + (clift * abdet);
				return sign >= 0;
				
			}*/
		}

		function findIntersection( p1, p2, p3, p4)
		{
			var dx12 = p2[X] - p1[X];
			var dy12 = p2[Y] - p1[Y];
			var dx34 = p4[X] - p3[X];
			var dy34 = p4[Y] - p3[Y];

			var denominator = (dy12 * dx34 - dx12 * dy34);
			var t1 = ((p1[X] - p3[X]) * dy34 + (p3[Y] - p1[Y]) * dx34) / denominator;
			if (t1 == Infinity)
			{
				return false;
			}

			//var t2 = ((p3[X] - p1[X]) * dy12 + (p1[Y] - p3[Y]) * dx12) / denominator;
			var intersection = [p1[X] + dx12 * t1, p1[Y] + dy12 * t1];
			return intersection;

		}

		function circle(a, b, c)
		{
		var center;
		var radius;
			if (c == undefined)
			{
				var diffX = ((a[X] - b[X])/2);
				var diffY = ((a[Y] - b[Y])/2);
				center = [diffX + b[X], diffY + b[Y]];
				radius = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
			}
			else	//Got link to these calculations from Mattias. http://csharphelper.com/blog/2016/09/draw-a-circle-through-three-points-in-c/
			{

				var x1 = (b[X] + a[X]) / 2;
				var y1 = (b[Y] + a[Y]) / 2;
				var dy1 = b[X] - a[X];
				var dx1 = -(b[Y] - a[Y]);

				var x2 = (c[X] + b[X]) / 2;
				var y2 = (c[Y] + b[Y]) / 2;
				var dy2 = c[X] - b[X];
				var dx2 = -(c[Y] - b[Y]);

				var intersection = findIntersection([x1, y1] , [x1 + dx1, y1 + dy1], [x2, y2], [x2 +dx2, y2+dy2]);

				if( intersection == false)
				{
					center = [0,0];
					radius = 0;
				}
				else
				{
					center = intersection;
					var dx = center[X] - a[X];
					var dy = center[Y] - a[Y];
					radius = Math.sqrt(dx*dx + dy*dy);
				}

				/*var m1 = (b[Y] - a[Y]) / (b[X] - a[X]);
				var m2 = (c[Y] - b[Y]) / (c[X] - b[X]);
				var x = (m1 * m2 * (c[Y] - a[Y]) + m1* (b[X]+c[X]) + m2 * (a[X] + b[X])) / (2 * (m1 - m2));
				var y = (1/m1) * (x - (a[X] + b[X]) / 2) + (a[Y] + b[Y]) / 2;
				center = [x, y]
				radius = Math.sqrt(Math.pow(x - a[X], 2) + Math.pow(y - a[Y], 2));
				*/
				/*
				float m1 = (point2.Y - point1.Y) / (point2.X - point1.X);
            float m2 = (point3.Y - point2.Y) / (point3.X - point2.X);

            float X = (m1 * m2 * (point3.Y - point1.Y) + m1 * (point2.X + point3.X) + m2 * (point1.X + point2.X)) / (2 * (m1 - m2));
            float Y = (1 / m1) * (X - (point1.X + point2.X) / 2) + (point1.Y + point2.Y) / 2;
            Center = new Vector2(X, Y);
            Radius = (Center - point1).Length();
				*/
			}
			return [center, radius];
		}
		
		function brute()
		{
			if(pointList.length < 2)
			{
				return [pointList[X], 0];
			}
			else if (pointList.length < 3)
			{
				var res = circle(pointList[0], pointList[1]);
				return res;
			}
			else 
			{
				var minCircle = [[0,0], Number.MAX_SAFE_INTEGER];
				for (var i = 0; i < pointList.length-1; i++)
				{
					var fault = false;
					for(var j = i+1; (j < pointList.length) && !fault; j++)
					{
						var tmpCirc = circle(pointList[i], pointList[j]);
						for (var k = 0; k < pointList.length && !fault; k++)
						{
							if(pointList[k] == pointList[i] || pointList[k] == pointList[j])
								continue;
							else
								if(!inside(tmpCirc, pointList[k]))//pointList[i], pointList[j], pointList[k]))
									fault = true;
						}
						if (fault)
							continue;
						if (tmpCirc[1] < minCircle[1])
							minCircle = tmpCirc;
					}
				}
				for (var i= 0; i < pointList.length-2; i++)
				{
					for(var j = i; j < pointList.length-1; j++)
					{
						var fault = false;
						for(var k = j; k < pointList.length && !fault; k++)
						{
							var tmpCirc = circle(pointList[i], pointList[j], pointList[k]);
							for(var l = 0; l < pointList.length && !fault; l++)
							{
								if(pointList[l] == pointList[i] || pointList[l] == pointList[j] || pointList[l] == pointList[k])
									continue;
								else
									if(!inside(tmpCirc, pointList[l])) //pointList[i], pointList[j], pointList[k], pointList[l]))
										fault = true;
							}
							if(fault)
								continue;
							if (tmpCirc[1] < minCircle[1])
								minCircle = tmpCirc;
						}
					}
				}
				return minCircle;
			}
		}

	</script>
</html>